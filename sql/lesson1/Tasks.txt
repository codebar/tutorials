
Notes for tutorial - a place for various ideas

Contents of this file -
Tasks),
Story),
Misc)

Tasks)

NOTE: T by the task number, e.g. 6 T) means this task has been used in the tutorial.

NOTE: the text for each task represents suggested tutorial phrases for tasks.

NOTE: these may or may not be done by the student, e.g. table creation and row insertions may be a bit of a slow start
or just too fiddly for beginners.

NOTE: need to decide what initial state of database will be.

NOTE: consider two start points/gists, one with tables & data, one without

		If initial state has no data or tables, student learns how to create and populate these. They also learn about
		fields and data types. If the initial state includes existing populated tables, the student has to be told
		about these things.

## starting

Put Story intro here (as defined in Story), below)

1) Create tables

a table can be considered to be similar to many excel worksheets. each column stores an item of data, such as
firstName, lastName, email, city, etc. a row stores all data for a single, entry in that table. People who work with
db's usually refer to columns as fields, and rows as ... rows.

2) Create autoincrement field for id columns

3) Insert data

4) sqlite settings

.mode column
.width 15
.headers on


## Query data - default ordering

To query data, we use the select keyword in this format:

```
select * from table_name
```

HINT:

When we search for data, the db does not guess where to look. We have to tell the db the tables to search in. We
replace "table_name" in "from table_name" by a specific table name.

 The * tells the db to return info on all fields.

> Jargon: the "*" is known as the "wildcard" operator. Roughly speaking, to SQL it means "everything".

5 T) select * from customers
(let's see all the people who've visited our store.)

## Limiting data (columns)

6 T)select firstName, lastName, email, city from customers;

SQL is very powerful at providing us with a lot of data for a simple query, but sometimes it's hard to see the wood
for the trees.

We can cut down the amount of data by specifying the column names of the data that interests us. Try that out now.

Did you find that was a bit easier to read through? From now on, decide for yourself whether to use * or to name
the columns.

> The jargon for the results we see is "returned rows" or the "rows returned".

7 T) select firstName, lastName, email, city from customers order by firstName, lastName;
 (that list still isn't very readable, is it?
 We can use order by to request that the computer arranges the data in a way more friendly to us humans.)



 (That was a lot better, wasn't it? We can order by any of the fields in a table. Have a go at this, making a small
 change to our last query)

8 T) asc, desc
The ordering was useful, but perhaps we prefer to look at the data in reverse order. By default, an order by query is
assumed to have "asc" at the end. This means ascending order. We can put this at the end to make our query clearer,
if we want.

A bit more usefully, if we put "desc" at the end, meaning descending, the order is reversed. Try out asc and desc with
the order by queries we just used. Ask your coach if you're not sure of anything.

9 T) select * from items

This is the definition for the table that stores info on pets. Write a query that shows info for all the pets, then
change that query to show them alphabetically.

That's excellent. Can you think of another interesting query for this table, using what we've learnt?


NOTE: at this point, I've started giving the task a title, rather than using the sql as the title. These tasks are all
an approx guide of the eventual tutorial document anyway.

## Limiting data (again, this time by rows)

10 T) Limiting data (max rows shown)

Sometimes, as well as limiting the columns shown, we only want to see some of the rows. For instance, when viewing
customers, perhaps we'd like to see only those at the start or end of the list. We do this with Limit.

Enter this to view the first five customers:
select firstName, lastName, email from customers order by lastName limit 5;

To view the last five customers, we first reverse the list order as above, then apply the limit:
select firstName, lastName, email from customers order by lastName desc limit 5;


xx T) Count of customers

As well as providing data, SQL can do some counting for us, too. It can be hard to count the number of results by
looking at the screen. It's much easier to let SQL do that for us.

To get a count of our customers we use the count function.

> Jargon: a function performs some action. You can spot them because they have the rounded brackets. The item between
the brackets affects the function in some way. Here we pass the wildcard.

```
select count(*) from customers;
```


xx T) More Limits (by comparing the data)

NOTE: refers to count(*) exercise, so must be placed after that on the tutorial page.

Up to now, the limits that we've applied with our queries has not been based on the data in the table. This is a very
useful technique, and it is easy to do.

Let's search for customers by area of the UK.

For instance, when viewing our customers, perhaps we'd like those who've come all the way from Scotland. We achieve
this using Where.

```
select firstName, lastName from customers where country = "Scotland";
```

Now, can you write query that tells us how many customers are from England? You understand enough now to have a go.
Ask your coach if you have any questions.

select count(*) from customers where country = "England";

xx T) inequality comparison

Let's find out how many customers visited us from anywhere else but England. We use the inequality operator this
time, but the db checks row by row, exactly as before.

```
select firstName, lastName from customers where country != "England";
```

Notice how this query finds customers from multiple places, and only ignores those from England. This is much
easier than us having to do this with the equality operator.

xx T) gtr, less than ops

We are now going to execute some comparisons on a table that stores numeric amounts, representing a customer payment.
This table is the **orders** table, which has a field named **amount**.

This table stores the amount paid for a purchase by a specific customer. The customer is represented in the table by
the **customer_id** field .

NOTE: we use the customer's id field to show specify a customer. This is more efficient for storage. But more important
than this, it means we do not duplicate info about the customer in the db. To do this would both require more effort to
enter info to db, and increase the chances of a mistake where the data is not the same in both places. Such mistakes
might cause queries to give incorrect results. This avoidance of duplication is called **normalisation**.
 CHECK phrasing

If you use count(*) on the orders table, it shows there are 50 order.

Now assume we want to know the orders of Â£35 or more. If we perform select * from orders, this is not easy to count.
Even if we use order by, it's a fiddly thing to do.

For a instant correct answer, we use the **greater than** operator.

```
select count(*) from orders where amount > 35;
```

less than

The **less than** operator works in the same way.

```
select count(*) from orders where amount < 35;
```

Note that we could have gotten the same result by switching amount and 35. Generally, it's best to write the query in
the way it sounds best to you.

xx T) test for similarity LIKE

The **LIKE** operator is very powerful when searching text fields. It is very common to look for text that matches some
pattern, e.g. a field that starts with some text.

In the items table, we use the name field to store item codes - "rabbit01", "food01", etc.

Here, we use "LIKE" with **%** to represent any or no characters, to search for all the pets:

```
select * from items where name like "rabbit%";
```

Experiment with "%" in some other queries that use "like", so you get a feel for how it works.

xx T) full income of store

We are starting to see some of the benefits of using a db, and now it's time to see that we can make the computer
perform calculations on numeric fields from multiple rows.

First, let's view all the amounts received from our customers.
 select amount from orders;

That provides a rough idea of how much money the store has brought in, but adding up all those numbers would tax most
people's mental arithmetic.

In SQL, it's easy to get add up the values several rows:

select sum(amount) from orders;

xx)

income from a specific customer

xx) customers from area

NOTE: query now used above, but not using "or" or "and"
(also using or, and etc)

select count(*) from customers where country = "England";

xx T) count of customers from area

select count(*) from customers where country = "England";

xx T) avg order price

xx T) min max order

min max order grouped by customer id

insert new customer
insert new order(s), delete one

select count(DISTINCT email) from
customers;


xx ) BONUS
Now you know enough to write your own **SQL** queries to compare the spending habits of two specific customers!

Your queries will tell us who, of two customers, has the highest average purchase amount, and who of the two made the smallest purchase. So, with help from your coach try and write a set of queries to do the following:

- View all customers in the table

- Pick two customers by name, and make a note of their id numbers
HINT: See the Greater Than section if this sounds unfamiliar

- In separate queries for each chosen customer, perform the following tasks:

- Find the purchase amounts made by that customer.
HINT: See the section on comparing data to values.

- Obtain the average purchase amount made by each customer.

 Hooray! We know now which, of the two customers, pays more on average than the other. Maybe it's a good to time to contact that customer and offer them a discount on their next purchase?

- Now adjust your queries to find which customer made the smallest purchase. Let your coach know if this is the same customer or the other one.

 Well done for getting this far!

  ```
  Hi! My name is _name_.
  A couple of things about me _about you_.
  I have attended _number of sessions_ Codebar sessions so far!
  ```

- if the number of sessions attended is 0
  ```
  This is the first time I'm attending Codebar!
  ```
- If the number of sessions attended is more than 0
  ```
  This is not my first time here. I <3 Codebar!
  ```




Story)

It might be good to suggest the rough idea of a story behind the tutorial and tasks.

Eg,
    The existing data is for a pet store that has been in business for a while.
    (this gives a reason for db already having data)

    (new table rows reflect new customers and pet purchases)

Also, it's helpful to have a story reason to create and populate a new table

e.g.
    sales of pet accessories, cat-sitting & dog-walking service


Misc)

1) details of different field data types may overwhelm the student with detail, or simply slow down the pace of
learning and leave the student feeling that they are not making progress and having fun.

2) Import from csv files

